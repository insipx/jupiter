logging {
  level = "debug"
}

// ============================================================
// PROMETHEUS REMOTE WRITE
// ============================================================
prometheus.remote_write "default" {
  endpoint {
    url = "http://kube-prometheus-stack-prometheus:9090/api/v1/write"
  }
}

prometheus.scrape "opnsense_node" {
  targets = [{
    __address__ = "10.10.69.1:9100",
    instance    = "fw-opnsense",
    job         = "node_exporter",
    group       = "firewall",
    host        = "fw-opnsense",
  }]

  forward_to = [prometheus.remote_write.default.receiver]
  scrape_interval = "15s"
  scrape_timeout = "10s"
}

prometheus.scrape "opnsense_exporter" {
  targets = [{
    __address__ = "opnsense-exporter:8080",
    instance    = "fw-opnsense",
    job         = "node_exporter",
    group       = "firewall",
    host        = "fw-opnsense",
  }]

  forward_to = [prometheus.remote_write.default.receiver]
  scrape_interval = "15s"
  scrape_timeout = "10s"
}

prometheus.scrape "unbound" {
  targets = [{
    __address__ = "10.10.69.1:9167",
    instance    = "unbound-dns",
    job         = "unbound",
  }]

  forward_to = [prometheus.remote_write.default.receiver]
  scrape_interval = "15s"
  scrape_timeout = "10s"
}

// ============================================================
// RELABEL RULES - Promote syslog internal labels
// ============================================================
loki.relabel "syslog_labels" {
  forward_to = []

  rule {
    source_labels = ["__syslog_message_app_name"]
    target_label  = "app"
  }

  rule {
    source_labels = ["__syslog_message_severity"]
    target_label  = "severity"
  }

  rule {
    source_labels = ["__syslog_message_facility"]
    target_label  = "facility"
  }

  rule {
    source_labels = ["__syslog_message_hostname"]
    target_label  = "host"
  }
}

// ============================================================
// SYSLOG SOURCE - receives all OPNsense syslog messages
// ============================================================
loki.source.syslog "opnsense" {
  listener {
    address = "0.0.0.0:1514"
    protocol = "udp"
    labels = {service = "opnsense", job = "opnsense-syslog", protocol = "udp"}
  }
  listener {
    address = "0.0.0.0:1514"
    protocol = "tcp"
    labels = {service = "opnsense", job = "opnsense-syslog", protocol = "tcp"}
  }

  relabel_rules = loki.relabel.syslog_labels.rules
  forward_to = [loki.process.opnsense.receiver]
}

// ============================================================
// LOG PROCESSING PIPELINE
// ============================================================
loki.process "opnsense" {
  forward_to = [loki.write.default.receiver]

  // --------------------------------------------------------
  // FILTERLOG IPv4 PARSING
  // Use regex filter in selector to only match IPv4 lines
  // --------------------------------------------------------
  stage.match {
    selector = "{app=\"filterlog\"} |~ \"^[0-9]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,4,\""
    pipeline_name = "filterlog_ipv4"

    // Match IPv4 filterlog and extract all fields in one regex
    // Format: rule,subrule,anchor,tracker,interface,reason,action,direction,4,tos,ecn,ttl,id,offset,flags,proto_id,proto,length,src_ip,dst_ip,src_port,dst_port,...
    stage.regex {
      expression = "^(?P<rule>\\d*),(?P<subrule>[^,]*),(?P<anchor>[^,]*),(?P<tracker>[^,]*),(?P<interface>[^,]*),(?P<reason>[^,]*),(?P<action>[^,]*),(?P<direction>[^,]*),4,(?P<tos>[^,]*),(?P<ecn>[^,]*),(?P<ttl>[^,]*),(?P<id>[^,]*),(?P<offset>[^,]*),(?P<flags>[^,]*),(?P<proto_id>[^,]*),(?P<proto>[^,]*),(?P<length>[^,]*),(?P<source_ip>[^,]*),(?P<dest_ip>[^,]*),(?P<source_port>[^,]*),(?P<dest_port>[^,]*).*$"
    }

    // Set ip_version label for IPv4
    stage.static_labels {
      values = {
        ip_version = "4",
      }
    }

    stage.labels {
      values = {
        action    = "",
        direction = "",
        interface = "",
        proto     = "",
      }
    }

    // Extract VLAN ID from interface name (e.g., igc0_vlan10 -> 10, igc0.10 -> 10)
    stage.regex {
      source     = "interface"
      expression = "^(?P<base_interface>[^_\\.]+)(?:[_\\.]vlan?(?P<vlan>\\d+))?$"
    }

    stage.labels {
      values = {
        vlan = "",
      }
    }

    // GeoIP enrichment for source IP
    stage.geoip {
      db      = "/etc/alloy/geoip/GeoLite2-City.mmdb"
      source  = "source_ip"
      db_type = "city"
    }

    stage.structured_metadata {
      values = {
        source_ip                = "",
        dest_ip                  = "",
        source_port              = "",
        dest_port                = "",
        rule                     = "",
        tracker                  = "",
        geoip_country_name       = "",
        geoip_country_code       = "",
        geoip_city_name          = "",
        geoip_location_latitude  = "",
        geoip_location_longitude = "",
        geoip_continent_name     = "",
      }
    }
  }

  // --------------------------------------------------------
  // FILTERLOG IPv6 PARSING
  // Use regex filter in selector to only match IPv6 lines
  // --------------------------------------------------------
  stage.match {
    selector = "{app=\"filterlog\"} |~ \"^[0-9]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,[^,]*,6,\""
    pipeline_name = "filterlog_ipv6"

    // Match IPv6 filterlog
    // Format: rule,subrule,anchor,tracker,interface,reason,action,direction,6,class,flow_label,hop_limit,proto,proto_id,length,src_ip,dst_ip,src_port,dst_port,...
    stage.regex {
      expression = "^(?P<rule>\\d*),(?P<subrule>[^,]*),(?P<anchor>[^,]*),(?P<tracker>[^,]*),(?P<interface>[^,]*),(?P<reason>[^,]*),(?P<action>[^,]*),(?P<direction>[^,]*),6,(?P<class>[^,]*),(?P<flow_label>[^,]*),(?P<hop_limit>[^,]*),(?P<proto>[^,]*),(?P<proto_id>[^,]*),(?P<length>[^,]*),(?P<source_ip>[^,]*),(?P<dest_ip>[^,]*),(?P<source_port>[^,]*),(?P<dest_port>[^,]*).*$"
    }

    stage.static_labels {
      values = {
        ip_version = "6",
      }
    }

    stage.labels {
      values = {
        action    = "",
        direction = "",
        interface = "",
        proto     = "",
      }
    }

    // Extract VLAN ID from interface name (e.g., igc0_vlan10 -> 10, igc0.10 -> 10)
    stage.regex {
      source     = "interface"
      expression = "^(?P<base_interface>[^_\\.]+)(?:[_\\.]vlan?(?P<vlan>\\d+))?$"
    }

    stage.labels {
      values = {
        vlan = "",
      }
    }

    stage.geoip {
      db      = "/etc/alloy/geoip/GeoLite2-City.mmdb"
      source  = "source_ip"
      db_type = "city"
    }

    stage.structured_metadata {
      values = {
        source_ip                = "",
        dest_ip                  = "",
        source_port              = "",
        dest_port                = "",
        rule                     = "",
        tracker                  = "",
        geoip_country_name       = "",
        geoip_country_code       = "",
        geoip_city_name          = "",
        geoip_location_latitude  = "",
        geoip_location_longitude = "",
        geoip_continent_name     = "",
      }
    }
  }

  // --------------------------------------------------------
  // SURICATA PARSING - IDS/IPS alerts (EVE JSON via syslog)
  // --------------------------------------------------------
  stage.match {
    selector = "{app=\"suricata\"}"

    stage.json {
      expressions = {
        event_type   = "event_type",
        src_ip       = "src_ip",
        src_port     = "src_port",
        dest_ip      = "dest_ip",
        dest_port    = "dest_port",
        proto        = "proto",
        alert_action = "alert.action",
        alert_sig    = "alert.signature",
        alert_sig_id = "alert.signature_id",
        alert_cat    = "alert.category",
        alert_sev    = "alert.severity",
        flow_id      = "flow_id",
      }
    }

    stage.labels {
      values = {
        event_type = "",
        proto      = "",
        alert_sev  = "",
        alert_cat  = "",
      }
    }

    stage.structured_metadata {
      values = {
        src_ip       = "",
        src_port     = "",
        dest_ip      = "",
        dest_port    = "",
        alert_sig    = "",
        alert_sig_id = "",
        alert_action = "",
        flow_id      = "",
      }
    }
  }

  // --------------------------------------------------------
  // UNBOUND DNS QUERY PARSING - handles query, reply, and info logs
  // --------------------------------------------------------

  // Parse query logs: [thread:id] query: CLIENT_IP DOMAIN TYPE CLASS
  stage.match {
    selector = "{app=\"unbound\"} |~ \"query:\""
    pipeline_name = "unbound_query"

    stage.regex {
      expression = "\\[(?P<thread>\\d+:\\d+)\\]\\s+query:\\s+(?P<client_ip>[\\d\\.a-fA-F:]+)\\s+(?P<query_domain>[^\\s]+)\\s+(?P<query_type>[A-Z0-9]+)\\s+(?P<query_class>\\w+)"
    }

    stage.labels {
      values = {
        query_type = "",
      }
    }

    stage.structured_metadata {
      values = {
        client_ip    = "",
        query_domain = "",
        query_type   = "",
      }
    }
  }

  // Parse reply logs: [thread:id] reply: CLIENT_IP DOMAIN TYPE CLASS RCODE TIME CACHE TTL
  stage.match {
    selector = "{app=\"unbound\"} |~ \"reply:\""
    pipeline_name = "unbound_reply"

    stage.regex {
      expression = "\\[(?P<thread>\\d+:\\d+)\\]\\s+reply:\\s+(?P<client_ip>[\\d\\.a-fA-F:]+)\\s+(?P<query_domain>[^\\s]+)\\s+(?P<query_type>[A-Z0-9]+)\\s+(?P<query_class>\\w+)\\s+(?P<rcode>\\w+)\\s+(?P<response_time>[\\d\\.]+)\\s+(?P<cache_status>\\d+)\\s+(?P<ttl>\\d+)"
    }

    stage.labels {
      values = {
        query_type = "",
        rcode      = "",
      }
    }

    stage.structured_metadata {
      values = {
        client_ip     = "",
        query_domain  = "",
        query_type    = "",
        rcode         = "",
        response_time = "",
        cache_status  = "",
      }
    }
  }

  // Parse info logs (redirects, transparent): [thread:id] info: ZONE ACTION CLIENT@PORT DOMAIN TYPE CLASS
  stage.match {
    selector = "{app=\"unbound\"} |~ \"info:\""
    pipeline_name = "unbound_info"

    stage.regex {
      expression = "\\[(?P<thread>\\d+:\\d+)\\]\\s+info:\\s+(?P<zone>[^\\s]+)\\s+(?P<action>\\w+)\\s+(?P<client_ip>[\\d\\.a-fA-F:]+)@(?P<client_port>\\d+)\\s+(?P<query_domain>[^\\s]+)\\s+(?P<query_type>[A-Z0-9]+)\\s+(?P<query_class>\\w+)"
    }

    stage.labels {
      values = {
        query_type = "",
        action     = "",
      }
    }

    stage.structured_metadata {
      values = {
        client_ip    = "",
        query_domain = "",
        query_type   = "",
        action       = "",
        zone         = "",
      }
    }
  }
}

// ============================================================
// LOKI WRITE ENDPOINT
// ============================================================
loki.write "default" {
  endpoint {
    url = "http://loki-gateway:80/loki/api/v1/push"
    tenant_id = "fake"
  }
}
